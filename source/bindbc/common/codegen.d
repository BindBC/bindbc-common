/+
+            Copyright 2022 â€“ 2023 Aya Partridge
+ Distributed under the Boost Software License, Version 1.0.
+     (See accompanying file LICENSE_1_0.txt or copy at
+           http://www.boost.org/LICENSE_1_0.txt)
+/
module bindbc.common.codegen;

enum mangleofCppDefaultCtor = (string[] syms) nothrow pure @safe{
	static if((){
		version(CppRuntime_Clang)    return true;
		else version(CppRuntime_Gcc) return true;
		else return false;
	}()){
		string ret = "_ZN";
		foreach(sym; syms){
			ret ~= toStrCT(sym.length) ~ sym;
		}
		return  ret ~ "C1Ev";
	}else static if((){
		version(CppRuntime_Microsoft)        return true;
		else version(CppRuntime_DigitalMars) return true;
		else return false;
	}()){
		string ret = "??0";
		foreach(sym; syms){
			ret ~= sym ~ "@";
		}
		version(D_X32){
			return ret ~ "@QAE@XZ";
		}else{
			return ret ~ "@QEAA@XZ";
		}
	}else static assert(0, "Unknown runtime, not sure what mangling to use. Please check how your compiler mangles C++ struct constructors and add code for it to `bindbc.common.codegen.mangleofCppDefaultCtor`.");
};
unittest{
	static if((){
		version(CppRuntime_Clang)    return true;
		else version(CppRuntime_Gcc) return true;
		else return false;
	}()){
		static assert(["ImGuiListClipper"].mangleofCppDefaultCtor() == "_ZN16ImGuiListClipperC1Ev");
		static assert(["bgfx", "Init"].mangleofCppDefaultCtor() == "_ZN4bgfx4InitC1Ev");
	}else static if((){
		version(CppRuntime_Microsoft)        return true;
		else version(CppRuntime_DigitalMars) return true;
		else return false;
	}()){
		version(D_X32){
			static assert(["ImGuiListClipper"].mangleofCppDefaultCtor() == "??0ImGuiListClipper@@QAE@XZ");
			static assert(["bgfx", "Init"].mangleofCppDefaultCtor() == "??0Init@bgfx@@QAE@XZ");
		}else{
			static assert(["ImGuiListClipper"].mangleofCppDefaultCtor() == "??0ImGuiListClipper@@QEAA@XZ");
			static assert(["bgfx", "Init"].mangleofCppDefaultCtor() == "??0Init@bgfx@@QEAA@XZ");
		}
	}
}

size_t badHash(string s) nothrow pure @safe{
	size_t ret = 0;
	for(size_t i = 0; i < s.length; i += 2){
		ret += s[i]; //yes, this is a *really* bad hashing algorithm!
	}

	return ret * s.length;
}

enum toStrCT = (size_t val) nothrow pure @safe{
	enum base = 10;
	
	if(!val) return "0";

	string ret;
	while(val > 0){
		ret = cast(char)('0' + (val % base)) ~ ret;
		val /= base;
	}
	return ret;
};

/**
NOTE: The functions generated by this function may change parameters and return values without a major release. Do not rely on them.
*/
enum makeFnBindFns = (bool staticBinding) nothrow pure @safe{
	string ret = `
/*regex: function decl => makeFnBinds decl
^[ \t]*([A-Za-z0-9_()*\[\]]+) (\w+) ?\(([A-Za-z0-9_()*, .=\[\]]*)\);
\t\t[q{$1}, q{$2}, q{$3}],
*/
enum makeFnBinds = (string[][] fns, bool isMemberFn=false) nothrow pure @safe{`;
	if(staticBinding){
		ret ~= `
	string ret = "";
	foreach(fn; fns){
		string attribs = "";
		if(fn.length >= 4){
			if(fn.length == 5){
				attribs = " " ~ fn[4];
			}
			ret ~= "\n\textern("~fn[3]~") ";
		}else if(fn.length == 3){
			ret ~= "\n\textern(C) ";
		}else assert(0);
		
		if(fn[1] == "this"){
			ret ~= "pragma(mangle, mangleofCppDefaultCtor([__traits(getCppNamespaces, typeof(this)), __traits(identifier, typeof(this))])) this(int _)"~attribs~";";
			ret ~= "\n\timport bindbc.common.codegen: mangleofCppDefaultCtor;";
		}else{
			ret ~= fn[0]~" "~fn[1]~"("~fn[2]~")"~attribs~";";
		}
	}
	return [[ret]];`;
	}else{
		ret ~= `
	string[][] ret;
	foreach(fn; fns){
		string[] item = ["", "", "", ""];
		
		string prefix;
		string hash = "";
		string attribs = "";
		if(fn.length >= 4){
			if(fn.length == 5){
				attribs = " " ~ fn[4];
			}
			prefix = "extern("~fn[3]~") ";
			if(fn[3] != "C"){
				item[3] = fn[2];
				import bindbc.common.codegen: badHash, toStrCT;
				hash = badHash(fn[2]).toStrCT();
			}
		}else if(fn.length == 3){
			prefix = "extern(C) ";
		}else assert(0);
		
		item[2] = fn[1];
		
		string hiddenArgs = "";
		string callPrefix = "";
		if(isMemberFn){
			hiddenArgs = "ref inout(typeof(this)) this_, ";
			callPrefix = "this, ";
		}
		if(fn[2].length > 3 && fn[2][$-3..$] == "..."){
			item[1] = fn[1];
			item[0] ~= "\n\t"~prefix~"package "~fn[0]~" function("~hiddenArgs~fn[2]~") "~fn[1]~";";
		}else{
			item[1] = "_" ~ fn[1] ~ hash;
			item[0] ~= "\n\t"~prefix~"package "~fn[0]~" function("~hiddenArgs~fn[2]~") _"~fn[1]~hash~";";
			if(fn[1] == "this"){ //constructor
				if(fn[2] == ""){ //default constructor
					item[0] ~= "\n\t"~prefix~"pragma(mangle, mangleofCppDefaultCtor([__traits(getCppNamespaces, typeof(this)), __traits(identifier, typeof(this))])) this(int _)"~attribs~"{ _this"~hash~"(this); }";
					item[0] ~= "\n\timport bindbc.common.codegen: mangleofCppDefaultCtor;";
				}else{
					item[0] ~= "\n\t"~prefix~"this("~fn[2]~")"~attribs~"{ _this"~hash~"("~callPrefix~"__traits(parameters)); }";
				}
			}else if(fn[0].length >= 4 && fn[0][$-4..$] == "void"){
				item[0] ~= "\n\t"~prefix~fn[0]~" "~fn[1]~"("~fn[2]~")"~attribs~"{ _"~fn[1]~hash~"("~callPrefix~"__traits(parameters)); }";
			}else{
				item[0] ~= "\n\t"~prefix~fn[0]~" "~fn[1]~"("~fn[2]~")"~attribs~"{ return _"~fn[1]~hash~"("~callPrefix~"__traits(parameters)); }";
			}
		}
		ret ~= item;
	}
	return ret;`;
	}
	ret ~= `
};

enum joinFnBinds = (string[][] list, string outerScope, string membersWithFns="") nothrow pure @safe{`;
	if(staticBinding){
		ret ~= `
	string joined = "@nogc nothrow{";`;
	}else{
		ret ~= `
	string joined = "\n@nogc nothrow __gshared{";`;
	}
	ret ~= `
	foreach(item; list){
		joined ~= item[0];
	}
	joined ~= "\n}";`;
	
	if(!staticBinding){
		ret ~= `
	joined ~= "\n\nimport bindbc.loader: SharedLib, bindSymbol;\nstatic void bindModuleSymbols(SharedLib lib) @nogc nothrow{";
	foreach(item; list){
		if(item[2] == "this") item[2] = "__ctor";
		if(item[3].length > 0){
			joined ~= "
	static if("~((item[3].length > 3 && item[3][$-3..$] == "...") ? "true" : "false")~" || __traits(getOverloads, "~outerScope~", \""~item[2]~"\").length > 0){
		static foreach(Fn; __traits(getOverloads, "~outerScope~", \""~item[2]~"\")){
			{
				void Fn2("~item[3]~"){}
				static if(is(typeof(Fn) Args1 == __parameters) && is(typeof(Fn2) Args2 == __parameters)){
					static if(is(Args1 == Args2)){
						lib.bindSymbol(cast(void**)&"~item[1]~", Fn.mangleof);
					}
				}else static assert(0);
			}
		}
	}else{
		lib.bindSymbol(cast(void**)&"~item[1]~", "~outerScope~"."~item[2]~".mangleof);
	}";
		}else{
			joined ~= "\n\tlib.bindSymbol(cast(void**)&"~item[1]~", "~outerScope~"."~item[2]~".mangleof);";
		}
	}
	if(membersWithFns.length > 0){
		joined ~= q{
		alias AliasSeq(T...) = T;
		static foreach(member; AliasSeq!(}~membersWithFns~q{)){
			static if( (is(member == struct) || is(member == class) || is(member == struct)) && (__traits(getLinkage, member) == "C++" || __traits(getLinkage, member) == "Objective-C") ){
				mixin(member,".bindModuleSymbols(lib);");
			}
		}
		};
	}
	joined ~= "\n}";`;
	}
	
	ret ~= `
	return joined;
};`;
	return ret;
};

enum makeExpandedEnum(Enum) = () nothrow pure @safe{
	string ret;
	foreach(member; __traits(allMembers, Enum)){
		ret ~= "\nenum "~member~" = "~Enum.stringof~"."~member~";";
	}
	return ret;
}();
